来源：《大话数据结构》

****

# 线性表

零个或多个数据元素的有限序列。

## 线性表的抽象数据类型

```c
ADT 线性表
Data
Operation
	InitList(*L) // 初始化空表
	ListEmpty(L) // 判断是否为空
	ClearList(*L) // 清空线性表
	GetElem(L, i, *e) // 将线性表L的第i个元素返回给e
	LocateElem(L, e) // 在线性表中查找与给定值e相等的元素
	ListInsert(*L, i, e) // 在线性表中第i个位置插入新元素e
	ListDelete(*L, i, *e) // 删除线性表L中第i个位置元素，并用e返回其值
	ListLength(L) // 返回线性表L的元素个数
endADT
```

## 线性表的顺序储存结构

#### 定义：

线性表的顺序储存结构，指的是用一段地址连续的存储单元依次存储线性表的数据元素。

```c
#define MAXSIZE 20
typedef int ElemType;
typedef struct
{
	ElemType data[MAXSIZE];
	int length;
} SqList;
```

#### 地址计算：

Loc(a[i]) = Loc(a[1]) + (i - 1)*c

其中，c为线性表中每个元素所占存储单元的个数。

#### 获取元素

返回数组中下标为i-1的元素。

#### 插入元素

插入算法思路：

* 如果插入位置不合理，抛出异常；
* 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量；
* 从最后一个元素开始向前遍历到第i个位置，分别将它们都向后移动一个位置；
* 将要插入元素填入i处；
* 表长加1；

代码如下：

```c
Status ListInsert(SqList *L, int i, ElemType e)
{
	int k;
    if (L->length == MAXSIZE)
        return ERROR;
    if (i < 1 || i > L->length + 1)
        return ERROR;
    if (i <= L->length)
    {
        for(k = L->length-1; k>=i-1;k--)
            L->data[k+1] = L->data[k];
    }
    L->data[i-1] = e;
    L->length++;
    return OK;
}
```



